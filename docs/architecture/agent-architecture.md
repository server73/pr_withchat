# 구매요청 Agent 아키텍처 설계

> 작성일: 2026-02-07
> 결정: **2안 — 스키마 기반 + LLM 판단 혼합 방식** 채택

---

## 1. 배경 및 문제 정의

### 현재 상태 (목업)
- `chatFlows.ts`에 대화 시나리오가 하드코딩되어 있음
- 구매유형별 질문 순서가 고정 (select_category → item_name → quantity → ...)
- 사용자는 정해진 순서대로만 값을 입력 가능

### 실제 운영 환경의 요구사항
- **고객사마다 구매 유형이 다름** (일반/IT/MRO 외에도 다양)
- **같은 유형이라도 고객사별 필수 항목이 다를 수 있음**
- **사용자의 자연어 입력**을 처리해야 함 ("노트북 3대 급하게 필요해요")
- 구매요청 생성 **MCP(API)**에서 요구하는 값을 빠짐없이 수집해야 함

---

## 2. 검토한 방식

### 1안: LLM 완전 자율 판단

MCP API 스펙만 LLM에 제공하고, 대화 흐름을 전적으로 LLM이 결정하는 방식.

| 장점 | 단점 |
|------|------|
| 자연스러운 대화 | 필수값 누락 위험 (환각) |
| 새 구매유형 추가 용이 | 결과 예측 불가, 테스트 어려움 |
| 개발 코드 단순 | 토큰 비용 높음 |
| | 고객사별 업무 규칙 반영 어려움 |

### 2안: 스키마 기반 + LLM 판단 (채택)

구매유형별 필수/선택 필드를 스키마로 정의하고, LLM이 대화하며 값을 채워나가는 방식.

| 장점 | 단점 |
|------|------|
| 필수값 100% 수집 보장 | 유형별 스키마 관리 필요 |
| 진행률 추적 가능 (5/8 수집 등) | 초기 설정 비용 |
| 고객사별 커스터마이징 용이 | |
| 토큰 효율적 | |
| 테스트/QA 가능 | |

---

## 3. 채택 방식 상세 설계

### 핵심 원칙

> **스키마는 "무엇을 모아야 하는가"를 정의하고, LLM은 "어떻게 자연스럽게 모을 것인가"를 담당한다.**

### 3.1 역할 분담

```
┌─────────────────────────────────────────────────┐
│  구매유형 스키마 (고객사별 설정 가능)                │
│  ┌───────────────────────────────────────┐       │
│  │ { type: "IT자산",                      │       │
│  │   fields: [                           │       │
│  │     { key: "itemCode",                │       │
│  │       type: "catalog", ... },         │       │
│  │     { key: "quantity",                │       │
│  │       type: "number", ... },          │       │
│  │     ...                               │       │
│  │   ]                                   │       │
│  │ }                                     │       │
│  └───────────────────────────────────────┘       │
└────────────────────┬────────────────────────────┘
                     ▼
┌─────────────────────────────────────────────────┐
│  LLM Agent (매 턴마다 판단)                       │
│                                                 │
│  Input:  스키마 + 수집현황 + 사용자메시지           │
│  Output: 추출된값 + 다음응답                       │
│                                                 │
│  · 한 메시지에서 여러 필드 동시 추출                │
│  · 미수집 필드를 자연어로 질문                      │
│  · 값 수정/정정 요청 처리                          │
│  · catalog 필드 → MCP Tool 직접 호출              │
│  · 모든 필수값 수집 시 → 확인 요청                  │
│                    │                             │
│              MCP Tool 호출 (Agent가 직접)          │
│                    ▼                             │
│  ┌─────────────────────────────────────┐         │
│  │  MCP Server (구매시스템)              │         │
│  │  · 품목 마스터 검색                   │         │
│  │  · 구매요청 생성 API                  │         │
│  │  · 예산 조회, 공급업체 조회 등         │         │
│  └─────────────────────────────────────┘         │
└────────────────────┬────────────────────────────┘
                     │ 응답 (메시지 + 검색 결과 등)
                     ▼
┌─────────────────────────────────────────────────┐
│  프론트엔드 (렌더링 전담)                          │
│  · 봇 메시지 표시                                 │
│  · 선택지 버튼 / CatalogPicker UI 렌더링          │
│  · 사용자 입력 수집 → Agent로 전달                 │
└─────────────────────────────────────────────────┘
```

> **핵심**: Agent가 MCP를 직접 호출한다. 프론트엔드는 Agent 응답을 렌더링할 뿐,
> 외부 시스템과 직접 통신하지 않는다.

### 3.2 스키마 구조 (예시)

```typescript
interface FieldSchema {
  key: string;           // API 필드명
  label: string;         // 사용자에게 보여줄 한글 라벨
  type: 'string' | 'number' | 'enum' | 'date' | 'text';
  required: boolean;     // 필수 여부
  values?: string[];     // enum일 경우 허용 값 목록
  validation?: {         // 검증 규칙
    min?: number;
    max?: number;
    pattern?: string;
  };
  description?: string;  // LLM에게 제공할 필드 설명
}

interface PurchaseTypeSchema {
  type: string;          // 구매 유형 코드
  label: string;         // 구매 유형 한글명
  description: string;   // LLM에게 제공할 유형 설명
  fields: FieldSchema[]; // 수집해야 할 필드 목록
}
```

### 3.3 LLM Agent의 매 턴 처리 흐름

```
1. 사용자 메시지 수신

2. LLM에 전달하는 컨텍스트:
   - 시스템 프롬프트 (역할, 톤앤매너)
   - 현재 구매유형 스키마
   - 수집 현황 (collected / missing)
   - 대화 히스토리
   - 사용자 최신 메시지

3. LLM 응답 (structured output):
   {
     "extracted_fields": {          // 이번 메시지에서 추출한 값
       "equipmentType": "노트북",
       "quantity": 3
     },
     "updated_fields": {},          // 수정 요청된 값
     "bot_message": "사양은 어떤 걸 원하시나요?",
     "suggested_options": ["i7/32GB", "i5/16GB"],  // 선택지 (optional)
     "is_ready_to_submit": false    // 모든 필수값 수집 완료 여부
   }

4. 프론트엔드 처리:
   - collected 상태 업데이트
   - 봇 메시지 렌더링
   - 선택지 버튼 표시 (있으면)
   - is_ready_to_submit이면 요약 카드 + 확인 버튼 표시
```

### 3.4 LLM이 담당하는 자율 판단 영역

| 판단 영역 | 예시 |
|-----------|------|
| **다중 필드 추출** | "노트북 3대 급하게" → equipmentType + quantity + urgency 동시 추출 |
| **자연어 질문 생성** | 미수집 필드 2개를 한 문장으로 자연스럽게 질문 |
| **값 수정 처리** | "아까 3대라고 했는데 5대로 바꿔주세요" → quantity 업데이트 |
| **유효성 안내** | "수량은 숫자로 입력해주세요" (type: number에 문자 입력 시) |
| **질문 순서 결정** | 남은 필드 중 어떤 것을 먼저 물을지 자율 판단 |
| **대화 톤 유지** | 고객사 설정에 따른 존칭/반말 등 |

### 3.5 스키마가 보장하는 영역

| 보장 영역 | 설명 |
|-----------|------|
| **필수값 완전성** | 모든 required 필드가 수집되기 전까지 제출 불가 |
| **타입 검증** | number 필드에 문자열이 들어가는 것 방지 |
| **enum 제약** | 허용된 값 목록 외의 값 거부 |
| **진행률 추적** | 수집된 필드 / 전체 필드 비율 표시 가능 |
| **고객사 커스터마이징** | 스키마 설정만으로 필드 추가/삭제/변경 |

---

## 4. 고객사 커스터마이징 시나리오

```
고객사 A (제조업):
  - IT자산 유형에 "자산번호", "설치장소" 필드 추가
  - MRO 유형에 "안전인증번호" 필수

고객사 B (금융):
  - 모든 유형에 "예산코드", "코스트센터" 필수
  - 일정 금액 이상 시 "결재라인" 필드 자동 추가

→ 코드 변경 없이 스키마 설정만으로 대응 가능
```

---

## 5. 품목 카탈로그 연동 (catalog 필드 타입)

### 5.1 문제 정의

실제 구매 시스템에서는 품목을 자유 텍스트로 받지 않고, **표준화된 품목코드**를 특정해야 한다.

```
사용자 입력: "노트북"

구매시스템 품목 마스터:
┌──────────────┬───────────────────────────┬──────────┐
│ 품목코드      │ 품목명                     │ 카테고리  │
├──────────────┼───────────────────────────┼──────────┤
│ IT-NB-001    │ 노트북 14인치 (사무용)      │ IT자산   │
│ IT-NB-002    │ 노트북 15인치 (개발용)      │ IT자산   │
│ IT-NB-003    │ 노트북 16인치 (고성능)      │ IT자산   │
│ IT-NB-004    │ 노트북 거치대              │ 사무용품  │
│ IT-NB-005    │ 노트북 파우치              │ 사무용품  │
└──────────────┴───────────────────────────┴──────────┘
```

단순 텍스트 수집이 아니라, **외부 시스템(품목 마스터)에서 검색 → 후보 제시 → 사용자 확정**의 흐름이 필요하다.

### 5.2 해법: `catalog` 필드 타입 추가

기존 `FieldType`에 `catalog`을 추가하고, 카탈로그 검색에 필요한 설정을 별도 인터페이스로 정의한다.

```typescript
// 필드 타입 확장
type FieldType = 'string' | 'number' | 'enum' | 'date' | 'text' | 'catalog';

// 카탈로그 검색 설정
interface CatalogConfig {
  source: string;            // MCP 검색 API 엔드포인트 (예: "item-master/search")
  displayFields: string[];   // 검색 결과에서 보여줄 컬럼 (예: ["code", "name", "category"])
  valueField: string;        // 확정 시 저장할 값 (예: "code" → "IT-NB-002")
  labelField: string;        // 화면에 보여줄 값 (예: "name" → "노트북 15인치 (개발용)")
  filters?: Record<string, string>;  // 사전 필터 (예: { category: "IT자산" })
  minSearchLength?: number;  // 최소 검색어 길이 (기본: 1)
  autoPopulate?: Record<string, string>;  // 품목 선택 시 다른 필드 자동 채움
                                          // 예: { "unitPrice": "price", "supplier": "vendorName" }
}

// FieldSchema 확장
interface FieldSchema {
  key: string;
  label: string;
  type: FieldType;
  required: boolean;
  values?: string[];
  validation?: FieldValidation;
  description?: string;
  placeholder?: string;
  catalogConfig?: CatalogConfig;  // type === 'catalog'일 때만 사용
}
```

### 5.3 스키마 정의 예시

```json
{
  "key": "itemCode",
  "label": "품목",
  "type": "catalog",
  "required": true,
  "description": "구매할 품목을 검색하여 선택",
  "catalogConfig": {
    "source": "item-master/search",
    "displayFields": ["code", "name", "spec", "unitPrice"],
    "valueField": "code",
    "labelField": "name",
    "filters": { "category": "IT자산" },
    "minSearchLength": 2,
    "autoPopulate": {
      "unitPrice": "unitPrice",
      "supplier": "vendorName"
    }
  }
}
```

### 5.4 대화 흐름 변화

```
[기존 — 텍스트 필드]
사용자: "노트북 구매하려고요"
봇:     "사양을 알려주세요"               ← 바로 다음 질문으로 이동

[변경 — catalog 필드]
사용자: "노트북 구매하려고요"
                │
                ▼
       Agent가 catalog 필드임을 인식
                │
                ▼
       Agent가 직접 MCP Tool 호출 (item-master/search?q=노트북)
                │
                ▼
       MCP가 검색 결과 반환 → Agent가 결과를 포함하여 응답
                │
                ▼
봇:     "노트북으로 검색한 결과입니다.
         해당하는 품목을 선택해주세요."

        ┌──────────────────────────────────────┐
        │  IT-NB-001  노트북 14인치 (사무용)     │
        │             단가: 1,200,000원         │
        ├──────────────────────────────────────┤
        │  IT-NB-002  노트북 15인치 (개발용)     │
        │             단가: 2,500,000원         │
        ├──────────────────────────────────────┤
        │  IT-NB-003  노트북 16인치 (고성능)     │
        │             단가: 3,800,000원         │
        ├──────────────────────────────────────┤
        │  🔍 다시 검색                         │
        └──────────────────────────────────────┘

사용자: (IT-NB-002 선택)
봇:     "'노트북 15인치 (개발용)' 선택하셨습니다.
         몇 대 필요하신가요?"
         ↑ autoPopulate로 unitPrice, supplier도 자동 수집됨
```

> **핵심**: 프론트엔드는 MCP를 호출하지 않는다. Agent가 MCP Tool을 직접 호출하고,
> 검색 결과를 정리하여 프론트엔드에 전달한다. 프론트엔드는 렌더링만 담당한다.

### 5.5 Agent 내부 처리 흐름 (MCP Tool 호출)

Agent는 사용자 메시지를 받으면 내부적으로 다음과 같이 처리한다:

```
1. 사용자: "노트북 구매하려고요"
2. Agent 판단: catalog 필드(itemCode)에 해당하는 입력 → MCP 검색 필요
3. Agent → MCP Tool 호출:
   {
     "tool": "item-master/search",
     "params": { "query": "노트북", "filters": { "category": "IT자산" } }
   }
4. MCP → Agent 응답:
   {
     "results": [
       { "code": "IT-NB-001", "name": "노트북 14인치 (사무용)", "unitPrice": 1200000 },
       { "code": "IT-NB-002", "name": "노트북 15인치 (개발용)", "unitPrice": 2500000 },
       { "code": "IT-NB-003", "name": "노트북 16인치 (고성능)", "unitPrice": 3800000 }
     ]
   }
5. Agent → 프론트엔드 응답 (검색 결과 포함):
```

```json
{
  "extracted_fields": {},
  "updated_fields": {},
  "bot_message": "노트북으로 검색한 결과입니다. 해당하는 품목을 선택해주세요.",
  "catalog_results": {
    "field_key": "itemCode",
    "query": "노트북",
    "items": [
      { "code": "IT-NB-001", "name": "노트북 14인치 (사무용)", "unitPrice": 1200000 },
      { "code": "IT-NB-002", "name": "노트북 15인치 (개발용)", "unitPrice": 2500000 },
      { "code": "IT-NB-003", "name": "노트북 16인치 (고성능)", "unitPrice": 3800000 }
    ]
  },
  "suggested_options": [],
  "is_ready_to_submit": false
}
```

> **프론트엔드의 역할**: `catalog_results`가 있으면 CatalogPicker UI를 렌더링할 뿐,
> MCP를 직접 호출하지 않는다. 모든 외부 시스템 연동은 Agent가 담당한다.

Agent의 MCP Tool 호출 시나리오:
| 시나리오 | Agent 행동 |
|----------|-----------|
| 사용자가 품목 관련 텍스트 입력 | Agent가 MCP `search` 호출 → 결과를 `catalog_results`에 포함 |
| 검색 결과가 너무 많음 | Agent가 추가 조건을 사용자에게 질문 → 재검색 |
| 검색 결과 없음 | Agent가 유사 키워드로 MCP 재호출 시도 → 그래도 없으면 사용자에게 안내 |
| 사용자가 품목 선택 | Agent가 `extracted_fields`에 확정값 저장 + autoPopulate 처리 |
| 사용자가 품목 변경 요청 | Agent가 MCP `search` 재호출 → 새 결과 제시 |

### 5.6 아키텍처 흐름

```
사용자 입력 "노트북"
       │
       ▼
┌──────────────────────────────────────────────┐
│  LLM Agent                                   │
│                                              │
│  1. 사용자 메시지 분석                         │
│  2. catalog 필드 → MCP 검색 필요 판단          │
│  3. MCP Tool 직접 호출 ──────────────┐        │
│                                     ▼        │
│                              ┌────────────┐  │
│                              │ MCP Server  │  │
│                              │ (구매시스템)  │  │
│                              │ 품목 마스터  │  │
│                              └─────┬──────┘  │
│                                    │         │
│  4. 검색 결과 수신 ←───────────────┘         │
│  5. 결과 정리 + 응답 메시지 생성               │
│                                              │
└──────────────────┬───────────────────────────┘
                   │  응답 (bot_message + catalog_results)
                   ▼
┌──────────────────────────────────────────────┐
│  프론트엔드                                    │
│                                              │
│  · bot_message 렌더링                         │
│  · catalog_results → CatalogPicker UI 표시    │
│  · 사용자 선택 → 다음 턴에 Agent로 전달         │
│                                              │
└──────────────────────────────────────────────┘
```

> **핵심 원칙**: Agent가 모든 외부 시스템 연동(MCP)을 담당하고,
> 프론트엔드는 Agent 응답을 렌더링하는 역할만 수행한다.
> 이로써 프론트엔드는 MCP 연동 로직을 알 필요가 없으며,
> Agent 측에서 MCP Tool을 추가/변경해도 프론트엔드 수정이 불필요하다.

### 5.7 복잡도가 증가하는 케이스

| 케이스 | 설명 | 대응 방안 |
|--------|------|-----------|
| **다단계 분류** | 대분류 → 중분류 → 소분류 순으로 좁혀가야 할 때 | `filters`를 동적으로 갱신하며 단계별 검색 |
| **검색 결과 없음** | 사용자 입력으로 품목을 못 찾을 때 | LLM이 유사 검색어 제안 또는 범위 확대 안내 |
| **검색 결과 과다** | 너무 많은 결과가 나올 때 | `refine` 액션으로 조건 추가 유도 |
| **품목 연계 속성** | 품목 선택 시 단가·납기·공급업체가 자동으로 결정 | `autoPopulate`로 관련 필드 자동 채움 |
| **고객사별 품목 마스터** | 고객사마다 품목 체계가 완전히 다름 | `source` 엔드포인트를 고객사별로 다르게 설정 |
| **품목 변경** | 이미 선택한 품목을 다른 것으로 변경하고 싶을 때 | LLM이 값 수정 의도 인식 → 재검색 트리거 |

### 5.8 프론트엔드 신규 컴포넌트

catalog 필드를 처리하기 위해 필요한 UI 컴포넌트:

| 컴포넌트 | 역할 |
|----------|------|
| `CatalogPicker` | 검색 결과를 카드/목록 형태로 표시, 선택 처리 |
| `CatalogSearchBar` | 인라인 재검색 입력 (결과 내에서) |
| `CatalogResultCard` | 개별 품목 카드 (코드, 명칭, 사양, 단가 표시) |

---

## 6. 현재 목업과의 관계

| 현재 목업 | 실제 구현 시 |
|-----------|-------------|
| `chatFlows.ts` (하드코딩 플로우) | 스키마 JSON/DB 기반 동적 로딩 |
| `useChatEngine.ts` (useReducer 상태머신) | LLM API 호출 + 수집 상태 관리 |
| QuickReplyButtons (고정 옵션) | LLM이 suggested_options으로 동적 제공 |
| PRSummaryCard (고정 레이아웃) | 스키마 기반 동적 렌더링 |
| 텍스트 입력 (자유 텍스트) | catalog 필드는 MCP 품목 검색 + CatalogPicker UI |

---

## 7. 향후 검토 사항

- [ ] LLM 모델 선정 (Claude / GPT 등) 및 프롬프트 엔지니어링
- [ ] 스키마 관리 방식 (JSON 파일 vs DB vs 관리 화면)
- [ ] MCP 서버 구현 및 API 연동 설계
- [ ] **품목 카탈로그 연동** — catalog 필드 타입 구현 및 CatalogPicker UI 개발
- [ ] **autoPopulate 메커니즘** — 품목 선택 시 연계 필드 자동 채움 로직
- [ ] 대화 히스토리 저장 및 세션 관리
- [ ] 에러 핸들링 (LLM 응답 실패, API 타임아웃 등)
- [ ] 토큰 비용 최적화 (컨텍스트 윈도우 관리)
